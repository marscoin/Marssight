/* Pure JavaScript buffertools implementation
 * Replaces native buffertools module for modern Node.js compatibility
 */

var SlowBuffer = require('buffer').SlowBuffer;
var Buffer = require('buffer').Buffer;
var events = require('events');
var util = require('util');

// Pure JS implementation of buffertools functions
var buffertools = {
  clear: function(buf) {
    buf.fill(0);
    return buf;
  },

  fill: function(buf, value) {
    if (typeof value === 'number') {
      buf.fill(value);
    } else if (Buffer.isBuffer(value)) {
      for (var i = 0; i < buf.length; i++) {
        buf[i] = value[i % value.length];
      }
    }
    return buf;
  },

  reverse: function(buf) {
    var len = buf.length;
    var half = Math.floor(len / 2);
    for (var i = 0; i < half; i++) {
      var tmp = buf[i];
      buf[i] = buf[len - 1 - i];
      buf[len - 1 - i] = tmp;
    }
    return buf;
  },

  compare: function(a, b) {
    return a.compare(b);
  },

  equals: function(a, b) {
    return a.equals(b);
  },

  indexOf: function(buf, search, start) {
    if (typeof search === 'string') {
      search = Buffer.from(search);
    }
    start = start || 0;
    return buf.indexOf(search, start);
  },

  concat: function() {
    var args = Array.prototype.slice.call(arguments);
    var totalLength = 0;
    for (var i = 0; i < args.length; i++) {
      if (Buffer.isBuffer(args[i])) {
        totalLength += args[i].length;
      }
    }
    return Buffer.concat(args.filter(Buffer.isBuffer), totalLength);
  },

  copy: function(src, dst, dstStart, srcStart, srcEnd) {
    return src.copy(dst, dstStart, srcStart, srcEnd);
  },

  toHex: function(buf) {
    return buf.toString('hex');
  },

  fromHex: function(str) {
    return Buffer.from(str, 'hex');
  }
};

exports.extend = function() {
  var receivers;
  if (arguments.length > 0) {
    receivers = Array.prototype.slice.call(arguments);
  } else if (typeof SlowBuffer === 'function') {
    receivers = [Buffer.prototype, SlowBuffer.prototype];
  } else {
    receivers = [Buffer.prototype];
  }
  for (var i = 0, n = receivers.length; i < n; i += 1) {
    var receiver = receivers[i];
    for (var key in buffertools) {
      receiver[key] = buffertools[key];
    }
    if (receiver !== exports) {
      receiver.concat = function() {
        var args = [this].concat(Array.prototype.slice.call(arguments));
        return buffertools.concat.apply(buffertools, args);
      };
    }
  }
};
exports.extend(exports);

//
// WritableBufferStream
//
function WritableBufferStream() {
  this.writable = true;
  this.buffer = null;
}

util.inherits(WritableBufferStream, events.EventEmitter);

WritableBufferStream.prototype._append = function(buffer, encoding) {
  if (!this.writable) {
    throw new Error('Stream is not writable.');
  }

  if (Buffer.isBuffer(buffer)) {
    // no action required
  }
  else if (typeof buffer == 'string') {
    buffer = Buffer.from(buffer, encoding || 'utf8');
  }
  else {
    throw new Error('Argument should be either a buffer or a string.');
  }

  if (this.buffer) {
    this.buffer = Buffer.concat([this.buffer, buffer]);
  }
  else {
    this.buffer = Buffer.alloc(buffer.length);
    buffer.copy(this.buffer);
  }
};

WritableBufferStream.prototype.write = function(buffer, encoding) {
  this._append(buffer, encoding);
  return true;
};

WritableBufferStream.prototype.end = function(buffer, encoding) {
  if (buffer) {
    this._append(buffer, encoding);
  }
  this.emit('close');
  this.writable = false;
};

WritableBufferStream.prototype.getBuffer = function() {
  if (this.buffer) {
    return this.buffer;
  }
  return Buffer.alloc(0);
};

WritableBufferStream.prototype.toString = function() {
  return this.getBuffer().toString();
};

exports.WritableBufferStream = WritableBufferStream;
