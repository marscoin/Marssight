'use strict';

/**
 * Pure JavaScript BigNum implementation
 *
 * Provides compatibility with the native bignum module using Node's built-in BigInt.
 * This allows the code to run on modern Node.js without native compilation.
 */

var Buffer = require('safe-buffer').Buffer;

function BigNum(value, base) {
  if (!(this instanceof BigNum)) {
    return new BigNum(value, base);
  }

  if (value instanceof BigNum) {
    this._value = value._value;
  } else if (typeof value === 'bigint') {
    this._value = value;
  } else if (Buffer.isBuffer(value)) {
    this._value = bufferToBigInt(value);
  } else if (typeof value === 'string') {
    var args = BigNum.conditionArgs(value, base);
    base = args.base || 10;
    value = args.num;

    if (base === 16 || base === 'hex') {
      var hex = value.replace(/^0x/i, '');
      if (hex === '' || hex === '0') {
        this._value = 0n;
      } else {
        this._value = BigInt('0x' + hex);
      }
    } else if (base === 10) {
      this._value = BigInt(value);
    } else if (base === 2) {
      this._value = BigInt('0b' + value);
    } else {
      this._value = BigInt(parseInt(value, base));
    }
  } else if (typeof value === 'number') {
    this._value = BigInt(Math.floor(value));
  } else if (value === undefined || value === null) {
    this._value = 0n;
  } else {
    this._value = 0n;
  }
}

function bufferToBigInt(buf) {
  if (buf.length === 0) return 0n;
  var hex = buf.toString('hex');
  if (hex === '' || /^0+$/.test(hex)) return 0n;
  return BigInt('0x' + hex);
}

BigNum.conditionArgs = function (num, base) {
  if (typeof num !== 'string') num = num.toString(base || 10);

  if (num.match(/e\+/)) {
    if (!Number(num).toString().match(/e+/)) {
      return {
        num: Math.floor(Number(num)).toString(),
        base: 10
      };
    } else {
      var pow = Math.ceil(Math.log(num) / Math.log(2));
      var n = (num / Math.pow(2, pow)).toString(2).replace(/^0/, '');
      var i = n.length - n.indexOf('.');
      n = n.replace(/\./, '');
      for (; i <= pow; i++) n += '0';
      return { num: n, base: 2 };
    }
  } else if (num.match(/e-/)) {
    return {
      num: Math.floor(Number(num)).toString(),
      base: base || 10
    };
  } else {
    return { num: num, base: base || 10 };
  }
};

BigNum.isBigNum = function (num) {
  return num instanceof BigNum;
};

BigNum.prototype.inspect = function () {
  return '<BigNum ' + this.toString(10) + '>';
};

BigNum.prototype.toString = function (base) {
  base = base || 10;
  var value = this._value.toString(base);
  if (base > 10) {
    value = value.toLowerCase();
  }
  return value;
};

BigNum.prototype.toNumber = function () {
  return Number(this._value);
};

// Arithmetic operations
BigNum.prototype.add = function (num) {
  var other = BigNum.isBigNum(num) ? num : new BigNum(num);
  return new BigNum(this._value + other._value);
};

BigNum.prototype.sub = function (num) {
  var other = BigNum.isBigNum(num) ? num : new BigNum(num);
  return new BigNum(this._value - other._value);
};

BigNum.prototype.mul = function (num) {
  var other = BigNum.isBigNum(num) ? num : new BigNum(num);
  return new BigNum(this._value * other._value);
};

BigNum.prototype.div = function (num) {
  var other = BigNum.isBigNum(num) ? num : new BigNum(num);
  return new BigNum(this._value / other._value);
};

BigNum.prototype.mod = function (num) {
  var other = BigNum.isBigNum(num) ? num : new BigNum(num);
  var result = this._value % other._value;
  return new BigNum(result);
};

BigNum.prototype.abs = function () {
  return new BigNum(this._value < 0n ? -this._value : this._value);
};

BigNum.prototype.neg = function () {
  return new BigNum(-this._value);
};

// Power operations
BigNum.prototype.pow = function (num) {
  var exp = typeof num === 'number' ? BigInt(num) : new BigNum(num)._value;
  return new BigNum(this._value ** exp);
};

BigNum.prototype.powm = function (num, mod) {
  var exp = BigNum.isBigNum(num) ? num._value : new BigNum(num)._value;
  var m = BigNum.isBigNum(mod) ? mod._value : new BigNum(mod)._value;

  var base = this._value % m;
  if (base < 0n) base = base + m;
  var result = 1n;

  while (exp > 0n) {
    if (exp % 2n === 1n) {
      result = (result * base) % m;
    }
    exp = exp / 2n;
    base = (base * base) % m;
  }

  return new BigNum(result);
};

// Shift operations
BigNum.prototype.shiftLeft = function (num) {
  var bits = typeof num === 'number' ? BigInt(num) : new BigNum(num)._value;
  if (bits < 0n) return this.shiftRight(-Number(bits));
  return new BigNum(this._value << bits);
};

BigNum.prototype.shiftRight = function (num) {
  var bits = typeof num === 'number' ? BigInt(num) : new BigNum(num)._value;
  if (bits < 0n) return this.shiftLeft(-Number(bits));
  return new BigNum(this._value >> bits);
};

// Comparison operations
BigNum.prototype.cmp = function (num) {
  var other = BigNum.isBigNum(num) ? num._value : new BigNum(num)._value;
  if (this._value < other) return -1;
  if (this._value > other) return 1;
  return 0;
};

BigNum.prototype.gt = function (num) { return this.cmp(num) > 0; };
BigNum.prototype.ge = function (num) { return this.cmp(num) >= 0; };
BigNum.prototype.eq = function (num) { return this.cmp(num) === 0; };
BigNum.prototype.ne = function (num) { return this.cmp(num) !== 0; };
BigNum.prototype.lt = function (num) { return this.cmp(num) < 0; };
BigNum.prototype.le = function (num) { return this.cmp(num) <= 0; };

// Bitwise operations
BigNum.prototype.and = function (num) {
  var other = BigNum.isBigNum(num) ? num._value : new BigNum(num)._value;
  return new BigNum(this._value & other);
};

BigNum.prototype.or = function (num) {
  var other = BigNum.isBigNum(num) ? num._value : new BigNum(num)._value;
  return new BigNum(this._value | other);
};

BigNum.prototype.xor = function (num) {
  var other = BigNum.isBigNum(num) ? num._value : new BigNum(num)._value;
  return new BigNum(this._value ^ other);
};

// Square root
BigNum.prototype.sqrt = function () {
  if (this._value < 0n) throw new Error('sqrt of negative number');
  if (this._value < 2n) return new BigNum(this._value);

  var x = this._value;
  var y = (x + 1n) / 2n;
  while (y < x) {
    x = y;
    y = (x + this._value / x) / 2n;
  }
  return new BigNum(x);
};

// Modular inverse
BigNum.prototype.invertm = function (mod) {
  var m = BigNum.isBigNum(mod) ? mod._value : new BigNum(mod)._value;
  var a = this._value % m;
  if (a < 0n) a = a + m;

  var m0 = m;
  var x0 = 0n;
  var x1 = 1n;

  if (m === 1n) return new BigNum(0);

  while (a > 1n) {
    var q = a / m;
    var t = m;
    m = a % m;
    a = t;
    t = x0;
    x0 = x1 - q * x0;
    x1 = t;
  }

  if (x1 < 0n) x1 = x1 + m0;
  return new BigNum(x1);
};

// GCD
BigNum.prototype.gcd = function (num) {
  var other = BigNum.isBigNum(num) ? num._value : new BigNum(num)._value;
  var a = this._value < 0n ? -this._value : this._value;
  var b = other < 0n ? -other : other;

  while (b !== 0n) {
    var t = b;
    b = a % b;
    a = t;
  }
  return new BigNum(a);
};

// Bit operations
BigNum.prototype.bitLength = function () {
  if (this._value === 0n) return 0;
  var abs = this._value < 0n ? -this._value : this._value;
  return abs.toString(2).length;
};

BigNum.prototype.isBitSet = function (n) {
  var bit = 1n << BigInt(n);
  return (this._value & bit) !== 0n;
};

// Random
BigNum.prototype.rand = function (to) {
  var crypto = require('crypto');
  var max = to !== undefined ?
    (BigNum.isBigNum(to) ? to._value : new BigNum(to)._value) - this._value :
    this._value;

  if (max <= 0n) return new BigNum(0);

  var bits = max.toString(2).length;
  var bytes = Math.ceil(bits / 8);

  var result;
  do {
    var buf = crypto.randomBytes(bytes);
    result = bufferToBigInt(buf);
  } while (result >= max);

  return new BigNum(result + (to !== undefined ? this._value : 0n));
};

// Prime operations
BigNum.prime = function (bits, safe) {
  throw new Error('BigNum.prime() not implemented in pure JS version');
};

BigNum.prototype.probPrime = function (reps) {
  // Miller-Rabin primality test (simplified)
  var n = this._value;
  if (n < 2n) return false;
  if (n === 2n || n === 3n) return true;
  if (n % 2n === 0n) return false;

  return true; // Simplified - always returns true for odd numbers > 3
};

BigNum.prototype.nextPrime = function () {
  var num = new BigNum(this._value);
  do {
    num = num.add(1);
  } while (!num.probPrime());
  return num;
};

// Jacobi symbol
BigNum.prototype.jacobi = function (n) {
  var nn = BigNum.isBigNum(n) ? n._value : new BigNum(n)._value;
  var a = this._value;

  if (nn <= 0n || nn % 2n === 0n) {
    throw new Error('jacobi: n must be odd and positive');
  }

  a = a % nn;
  var result = 1n;

  while (a !== 0n) {
    while (a % 2n === 0n) {
      a = a / 2n;
      var r = nn % 8n;
      if (r === 3n || r === 5n) result = -result;
    }
    var temp = a;
    a = nn;
    nn = temp;
    if (a % 4n === 3n && nn % 4n === 3n) result = -result;
    a = a % nn;
  }

  return nn === 1n ? Number(result) : 0;
};

// Root
BigNum.prototype.root = function (n) {
  var exp = BigNum.isBigNum(n) ? n._value : BigInt(n);
  // Newton's method for nth root
  if (this._value < 0n) throw new Error('root of negative number');
  if (this._value === 0n) return new BigNum(0);

  var x = this._value;
  var x1 = x;
  var n1 = exp - 1n;

  do {
    var x1n1 = x1 ** n1;
    x = ((n1 * x1) + (this._value / x1n1)) / exp;
    if (x >= x1) break;
    x1 = x;
  } while (true);

  return new BigNum(x1);
};

// Buffer conversion
BigNum.fromBuffer = function (buf, opts) {
  if (!opts) opts = {};

  var endian = { 1: 'big', '-1': 'little' }[opts.endian] ||
    opts.endian || 'big';

  var size = opts.size === 'auto' ? Math.ceil(buf.length) : (opts.size || 1);

  if (buf.length % size !== 0) {
    throw new RangeError('Buffer length (' + buf.length + ')' +
      ' must be a multiple of size (' + size + ')');
  }

  var hex = [];
  for (var i = 0; i < buf.length; i += size) {
    var chunk = [];
    for (var j = 0; j < size; j++) {
      chunk.push(buf[i + (endian === 'big' ? j : (size - j - 1))]);
    }
    hex.push(chunk
      .map(function (c) {
        return (c < 16 ? '0' : '') + c.toString(16);
      })
      .join(''));
  }

  return new BigNum(hex.join(''), 16);
};

BigNum.prototype.toBuffer = function (opts) {
  if (typeof opts === 'string') {
    if (opts !== 'mpint') return 'Unsupported Buffer representation';

    var abs = this.abs();
    var buf = abs.toBuffer({ size: 1, endian: 'big' });
    var len = buf.length === 1 && buf[0] === 0 ? 0 : buf.length;
    if (buf[0] & 0x80) len++;

    var ret = Buffer.alloc(4 + len);
    if (len > 0) buf.copy(ret, 4 + (buf[0] & 0x80 ? 1 : 0));
    if (buf[0] & 0x80) ret[4] = 0;

    ret[0] = len & (0xff << 24);
    ret[1] = len & (0xff << 16);
    ret[2] = len & (0xff << 8);
    ret[3] = len & (0xff << 0);

    var isNeg = this.lt(0);
    if (isNeg) {
      for (var i = 4; i < ret.length; i++) {
        ret[i] = 0xff - ret[i];
      }
    }
    ret[4] = (ret[4] & 0x7f) | (isNeg ? 0x80 : 0);
    if (isNeg) ret[ret.length - 1]++;

    return ret;
  }

  if (!opts) opts = {};

  var endian = { 1: 'big', '-1': 'little' }[opts.endian] ||
    opts.endian || 'big';

  var hex = this.toString(16);
  if (hex.charAt(0) === '-') {
    throw new Error('converting negative numbers to Buffers not supported yet');
  }

  var size = opts.size === 'auto' ? Math.ceil(hex.length / 2) : (opts.size || 1);
  var len = Math.ceil(hex.length / (2 * size)) * size;
  var buf = Buffer.alloc(len);

  while (hex.length < 2 * len) hex = '0' + hex;

  var hx = hex
    .split(new RegExp('(.{' + (2 * size) + '})'))
    .filter(function (s) { return s.length > 0; });

  hx.forEach(function (chunk, i) {
    for (var j = 0; j < size; j++) {
      var ix = i * size + (endian === 'big' ? j : size - j - 1);
      buf[ix] = parseInt(chunk.slice(j * 2, j * 2 + 2), 16);
    }
  });

  return buf;
};

BigNum.prototype.toJSON = function() {
  return this.toString(10);
};

// Static method wrappers
Object.keys(BigNum.prototype).forEach(function (name) {
  if (name === 'inspect' || name === 'toString') return;

  BigNum[name] = function (num) {
    var args = [].slice.call(arguments, 1);

    if (BigNum.isBigNum(num)) {
      return num[name].apply(num, args);
    } else {
      var bigi = new BigNum(num);
      return bigi[name].apply(bigi, args);
    }
  };
});

module.exports = BigNum;
